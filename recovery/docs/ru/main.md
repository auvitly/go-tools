## Оглавление
1. [Постановка проблемы](#problem)
2. [Описание](#desc)

---

<a name="problem"></a>
### 1. Постановка проблемы

Исключения могут стать большой проблемой как в разработке, так и эксплуатации. Для обеспечения
стабильности работы разрабатываемых продуктов требуется обработка исключений. Методика обычно сводится
к следующей конструкции:
```go
func main() {
    defer func(){
        if msg := recover; msg != nil {
            // Do something.
        }   	
    }()
	
    panic("hello")
}
```

Часто разработчики принебрегают практикой обработки исключений, так как добавлять подобные обработчики 
в каждую функцию трудозатратно и представляет рутинную задачу. Обычно паники отлавливаются
на этапе написания тестов, однако даже 100% покрытие кода тестами не всегда может гарантировать 
защиту от исключений (например, когда используется рефлексия). Также иногда требуется выполнить
действия по устранению последствий возникновения паники.

Можно выделить следующие проблемы:
* Рутинность процесса;
* Отсутствие единого подхода;
* Удобство обработки.

<a name="desc"></a>
### 2. Описание
Основным методом для обработки исключений является метод `Do`, который перехватывает ошибку и 
позволяет безопасно завершиться вызывающей функции. 
```go
func MyFunc() {
    defer recovery.Do()
    
    panic("msg")	
}
```

Если необходимо ограничить время выполнения, то используйте метод `DoContext`.

```go
func MyFunc(ctx context.Context) {
    defer recovery.DoContext(ctx)
    
    panic("msg")	
}
```

Для управления поведением при возникновении исключения используется механизма конструктора `recovery.Builder`. 
Пакет представляет целый набор методов для работы, поэтому ручной инициализации не требуется. 

Для настройки обработчика паники используется:
* `On` - метод позволяет выполнить обогащение [стандартной ошибки](./../../../stderrs/README.md) 
при обработке исключения паникой. Сбрасывает результат работы `OnError`.
* `OnError` - метод позволяет выполнить обогащение паникой стандартного интерфейса `error`.
Сбрасывает результат работы `On`.
* `SetMessage` - позволяет установить сообщение в [стандартную ошибку](./../../../stderrs/README.md) 
при обнаружении паники.
* `WithHandlers` - добавление пользовательских обработчиков исключения. 

Пользовательские обработчики должны удовлетворять сигнатуре:
```go
type Handler func(ctx context.Context, msg any) error
```

> Пользовательские обработчики запускаются **асинхронно**! 
> Если контекст был завершен, то обработчики выполняются на основании правил, 
> установленных разработчиком. Это крайне важно, так как это может порождать **утечку горутин**!



Пример настройки пользовательского обработчика события со стандартной ошибкой:
```go
func log(_ context.Context, msg any) error {
	slog.Error("we obtain panic: %v", msg)
	
	return nil
}

func DoSomething() (result any, err *stderrs.Error) {
	defer recovery.SetMessage("Oh no!").WithHandlers(log).On(&err).Do()
	
	panic("message")
}
```

При возникновении исключения будет вызвана функция `log`, затем будет сформирована ошибка, которая
подменит `err` обогащенной ошибкой с сообщением `Oh no!`.

> Отметим, что сначала выполняются обработчики, а затем уже формируется ошибка.
> Это связано с тем, что пакет также учитывает исключения в самих обработчиках. 
> И обогащает результирующую ошибку сообщениями паники.

Если требуется установить ряд глобальных обработчиков, которые будет выполняться при использовании `Do`,
то используется метод `RegistryHandlers`:

```go
func main() {	
    recovery.RegistryHandlers(func (_ context.Context, msg any) error {
        slog.Error("we obtain dontpanic: %v", msg)
        
        return nil
    })
	
    ...
}

func MyFunc() {
    defer recovery.Do()
    
    panic("msg")
}
```
Благодаря объявлению в `main` обработчика, то при вызове функции `MyFunc` будет выводить 
сообщение с паникой в лог. 
