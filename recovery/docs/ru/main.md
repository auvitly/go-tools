## Оглавление
1. [Постановка проблемы](#problem)
2. [Описание](#desc)
3. [Пример использования](#example)

---

<a name="problem"></a>
### 1. Постановка проблемы

Исключения могут стать большой проблемой как в разработке, так и эксплуатации. Для обеспечения
стабильности работы разрабатываемых продуктов требуется обработка исключений. Методика обычно сводится
к следующей конструкции:
```go
func main() {
    defer func(){
        if msg := recover; msg != nil {
            // Do something.
        }   	
    }()
	
    panic("hello")
}
```

Часто разработчики принебрегают практикой обработки исключений, так как добавлять подобные обработчики 
в каждую функцию трудозатратно и представляет рутинную задачу. Обычно паники отлавливаются
на этапе написания тестов, однако даже 100% покрытие кода тестами не всегда может гарантировать 
защиту от исключений (например, когда используется рефлексия). Также иногда требуется выполнить
действия по устранению последствий возникновения паники.

Можно выделить следующие проблемы:
* Рутинность процесса;
* Отсутствие единого подхода;
* Удобство обработки.

<a name="desc"></a>
### 2. Описание

Основным методом для обработки исключений является метод `Do`, который перехватывает ошибку и 
позволяет безопасно завершиться вызывающей функции. 
```go
func MyFunc(ctx context.Context) {
    defer recovery.Do(ctx)
    
    panic("msg")	
}
```

Для управления поведением при возникновении исключения используется механизма конструктора `recovery.Builder`. 
Пакет представляет целый набор методов для работы, поэтому ручной инициализации не требуется. 

Для настройки обработчика паники используется:
* `On` - метод позволяет выполнить обогащение [стандартной ошибки](./../../../stderrs/README.md) 
при обработке исключения паникой. Исключает действие метода `OnError`.
* `OnError` - метод позволяет выполнить обогащение паникой стандартного интерфейса `error`.
Исключает действие метода `On`.
* `SetMessage` - позволяет установить сообщение в [стандартную ошибку](./../../../stderrs/README.md) 
при обнаружении паники.
* `WithHandlers` - добавление пользовательских обработчиков исключения. 
Обработчики запускаются синхронно с прочими синхронными обработчиками в отдельной **goroutine**.
* `WithAsyncHandlers` - добавление пользовательских обработчиков исключения выполняемых асинхронно. 
Каждый асинхронный обработчик запускается каждый в своей **goroutine**.

Пользовательские обработчики должны удовлетворять сигнатуре:
```go
type Handler func(ctx context.Context, msg any)
```

<details>
    <summary>Особенности работы с обработчиками</summary>

> Пользовательские обработчики всегда запускаются **асинхронно**.
>
> На каждую обработку паники всегда порождается 1 **goroutine** для выполнения синхронных обработчиков, 
> а также N **goroutine** в соотствии с числом асинхронных обработчиков.
> Если контекст был завершен, обработка паники завершится, выполнив обогащение переданной ошибки.
> Если в период жизни контекста обработчики завершаться ошибкой, то информация об этом будет добавлена
> к обогащаемой ошибке, иначе сообщение об исключении залогированого при помощи стандартного пакета slog.

</details>



Пример настройки пользовательского обработчика события со стандартной ошибкой:
```go
func log(ctx context.Context, msg any) error {
    slog.ErrorContext(ctx, "we obtain panic: %v", msg)
	
	return nil
}

func DoSomething(ctx context.Context) (result any, err *stderrs.Error) {
	defer recovery.SetMessage("Oh no!").WithHandlers(log).On(&err).Do(ctx)
	
	panic("message")
}
```

При возникновении исключения будет вызвана функция `log`, затем будет сформирована ошибка, которая
переопределит `err` стандартной ошибкой с сообщением `Oh no!`.

> Отметим, что сначала выполняются обработчики, а затем уже формируется ошибка.
> Это связано с тем, что пакет также учитывает исключения в самих обработчиках. 
> И обогащает результирующую ошибку сообщениями паники.

Если требуется установить ряд глобальных обработчиков, которые будет выполняться при использовании `Do`,
то используются методы `RegistryHandlers` и `RegistryAsyncHandlers`:

```go
func main() {	
    recovery.RegistryHandlers(func (ctx context.Context, msg any) error {
        slog.ErrorContext(ctx, "we obtain panic: %v", msg)
        
        return nil
    })
	
    ...
}

func MyFunc(ctx context.Context) {
    defer recovery.Do(ctx)
    
    panic("msg")
}
```

Благодаря объявлению в `main` обработчика, то при вызове функции `MyFunc` будет выводить 
сообщение с паникой в лог:
```
[ERROR] we obtain panic: msg
```

<a name="example"></a>
### 3. Примеры использования

* Демонстрация механизма перехвата паники c пользовательскими обработчиками [[ссылка](../../../examples/relax/main.go)]